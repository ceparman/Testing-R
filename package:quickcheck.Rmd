---
title: "quickcheck Package"
author: "Craig Parman"
date: "2/24/2015"
output: pdf_document
---




###Introduction

The package quickcheck from [RevolutionAnalytics] http://www.revolutionanalytics.com adds a twist to unit testing. Rather than specifing exact values to be tested, set of random values of a particular type is passed.  


Here is a simple example.  Let's test thet the funtion returns a numeric value. A simple test using testthat might look like:

```{r}
library(testthat)

test_that("rest for floor", expect_identical(is.numeric(floor(3.14)), TRUE))


```

Here we specify the exact value 3.14 to be passed to the function floor.  With quickcheck you don't specify the value, but rather the type of a set of random variables to be passed to the function.  The function, `test`, uses randomly generate input values created by a generator function to test the assertion and collects the result.

```{r}
library(quickcheck)

test(function(x = rdouble())  identical(is.numeric(floor(x)), TRUE))


```



The test is not being run on a single value for x, but a series of values of type double generated by rdouble.  

In the example, the generator `rdouble` generated a list of random value of type double and passes then to `identical(is.numeric(floor(x)), TRUE)`. The these componts together form the assertion. The assertion must return a logical vector of length 1.  Now tha you get the idea lets look at the components closer.

###Building tests


The main function in quickcheck in test. The usage is:

`test(assertion, sample.size = 10, stop = !interactive())'. 

The `assertion` is a function and must return a single logical value for each time the assertion is tested. The returned logical value determines if the test has passed. The value for `sample.size` determines how many time to check the assertion and `stop` determines where a failed test and the associated error will stop R execution.

When the assertion returns TRUE value returned by `test` is `TRUE`. If the assertion returns `FALSE` the output depends on the `stop` parameter. If `stop` is `FALSE` a list with three elements is returned consisting of 1) the assertion 2) a list of in scope variabels (not fully implemented as of Feb. 2015), 3) List of arguments for each run. If the stop is `TRUE` a file is created which contants the list with the above values and is named `test.cases`. This file can be used to replicate errors. The error messsage generated reports the file names.


The most trival test that we could contruct would be:

```{r}

test(function()TRUE)

```

Here we are just returning TRUE, so the test is passed.  In fact we ran the test 10 times, as that is the default for how many time the assertion is checked.  If we wan to so see that we can run.

```{r}

t<-test(function()FALSE, sample.size = 2, stop=FALSE)
 

```

In the output see that the test failed twice and there are 2 cases in the cases portion of the output list.

```{r error=TRUE}

t<-test(function(x=rdouble())FALSE, sample.size = 2, stop=FALSE)

```







The generator, in this case `rdouble` can take on many different forms and the package provide serveral built in and a mechanism to create your own.

In fact you not only get a random set of doubles, you get a randon number of values.  To see this lets run rdouble twice.  We will set the random number seed to 0 for reproducibility.

```{r}
library(quickcheck)

set.seed(0)

rdouble()

rdouble()

```

 
In the first case we get 13 values and in the second we get 9.  We can further control the number generation with the element and size parameters. The element value sets expectation of the values and size sets the average number of values returned as displayed below.


```{r}
library(quickcheck)

set.seed(0)

set1 <- rdouble(element=100,size=10)

set2 <-rdouble(element=10,size=100)

mean(set1)
length(set1)

mean(set2)
length(set2)

```


We will look at the generators more depply in the section in generators.


##Usage

### Installing

Currently the quickchecl package is available fro GitHub. With the devtools package you can install it directly from GitHub.

```{r}

library(devtools)
install_github("RevolutionAnalytics/quickcheck@3.0.0", subdir = "pkg")`

``

###Defining Generators

Generator ceate the values that are tested against.  There are built in generators for most data types.  If needed custom generators can be generated for cases where specific values, or mixed types are needed.  On thing to keep in min is that these generators not only return randome values, but also random numbers of values.  This can be overridden, but the default behavior is to return an random number of random variable as defined by the call.

#### Built in genertators

Below is the list of buitl in generators.  There are atomic, 2 dimensional, and lists avaialble.  Then a type can consructed from a variaty of atomic types, each call to that generator will create a 

| Generator   | Elements          | Usage                                                  |
|------------ |-----------------  | -------------------------------------------------------|
| rany        | all generators    | rany() , rany(list(rdouble,rinteger))                  |
| rcharacter  | characters        | rcharacter(element = 10, size = 10)                    |
| rfactor     | factors           | rfactor(element = 10, size = 10)                       |
| constant    | constant value    | constant(const = 3)()                                  |
| rdata.frame | data.frame        | rdata.frame(element = ratomic, nrow = 10, ncol = 5)    |
| rmatrix     | matrix of atomics | rmatrix(element, nrow, ncol)                           |
| ratomic     | atomics           | ratomic(element = atomic.generators, size = 10)        |
| rdouble     | doubles           | rdouble(element = 0, size = 10)                        |
| rDate       | Dates             | rDates(element = list(from=Sys.Date()-10,to=Sys.Date())|
| rinteger    | integers          | rinteger(element = 100, size = 10)                     |
| rnumeric    | all numerics      | rnumeric(element = 100, size = 10)                     |
| rlist       | list of atomics   | rlist(), rlist(element=list(rdouble(siz=2)))           |
| rlogical    | logicals          | rlogical(element = 0.5, size = 10)                     |
| rraw        | raw values        | rraw(element = as.raw(0:255), size = 10)               |


You have the ability to fine tune the generators with the size and element parameters.  The element parameter can be used to control the values goint into the list.  The values for element can be a single value, a vector, or a random number generator.  


```{r}

rinteger(element = 30:50,size =10 )

rdouble(element = rnorm(10,mean=2,sd=.2),siz=20 )

```


There are two helper function for generators.  The first is `mixture`.   'Mixture' creates a random generator that creates an equally weighted mixture distribution of the generators.
Repeated calls will randomly generate vaules of one one the generators. you can also use a formula syntax to pass parameters to the generating function as shown in the last example.  This allows us to ensure that exactly size number of values are returned otherwise recycling is used. 

```{r}

set.seed(0)

mixture(list(rlogical,rcharacter))() 

mixture(list(rlogical,rcharacter))() 

#pass the size parameter to runif 

rdouble(element = ~runif(size, min = -1))


```

The `size` parameter can be used to control the expectation for the number of elements returned.  Ror example `rdouble(size = 100)' would eturn vectors of doubles with an aveage length of 100.  You can get an exact number of values by setting the size parameter with the constant function of the functional notation ~.

```{r}

rdouble(size = constant(4))

rdouble(size = ~4)
```

For nested objects such as list you can add the height parameter.  This control the maximun depth of nesting.  For 2 dimentional obljects size is replaced with nrow and ncol, both with the same behavior as size.

```{r}
set.seed(0)

rlist(height=4,size=2)

rmatrix(nrow=~2,ncol=~4)

```



The function allows you to randomly select vaules from a vector of values with or without replacement.

```{r}

select(c(1,TRUE,"gg",4),replace=TRUE)(size=10)

```

#### Constructing custom generators

The built in generator can be used to contruct a new generator.  For examples we can combine use mixture to create a list with integers and characters. 

```{r}
set.seed(0)
rlist(mixture(list(rinteger,rcharacter)),size=constant(3))
```

Let say we need a generator that constructs a matrix of integers.  We can use the rinteger generator to create the values for the matrix.  We must fix the length of the values returned by rinteger to nrow*ncol so we don't recycle values.  We will call the new function rIntMatrix


```{r}

rIntMatrix<-function(element=100,nrow=5,ncol=5)
{
  nr<-quickcheck:::rsize(nrow)
  nc<-quickcheck:::rsize(ncol)

 matrix( rinteger(element=element, size=constant(nc*nr)) ,nr,nc)  
    
}

set.seed(0)

rIntMatrix(element=50,nrow=4,ncol=5)


```


###Defining Assertions


The assertion you create with quickcheck can leverage the expectations from the testthat package.  Quickcheck used a set derived from the testthat package.  They use the same name exect thet the leading expect_ is removed. 

##### Expectation Types in Quickcheck

 equal            equal_to_reference   equivalent    error    false    
 identical        is                   less_than     match    message  
 more_than        named                null          output   that     
 true             warning                                              


The use of the test is pretty obvious.  Details for the specific cases can be found in the testthat help. Below are a few simple tests that use different expectations that highlight the usage.


```{r}

test(function(x=rcharacter()) expect("error", 1/x ))

test(function(x=rcharacter()) expect("named", data.frame(data=x) ))

test(function(x=rcharacter()) expect("match", x,"[:alnum:]*" ))

 test(function(x=rinteger()) expect("less_than",sum(x),sum(x+1)))
```


### Debugging Failed Tests

Unfortunately your code will most likely not pass every test.  when a test fails quickcheck lets you know what failed and which specfic cases failed. Here is a test that is sure to fail.


```{r error=TRUE}
set.seed(0)
test(function(x=rinteger()) expect("more_than",sum(x),sum(x+1)), stop = FALSE, sample.size=2)

```

We as expected the test failed and the test function reported which tests failed and the value for each case.  We can caputure this outout for later debuging.  Here the output is captured in out. The function repro loads this case and starts he debugger.

```{r error=TRUE}
set.seed(0)
out = test(function(x=rinteger()) expect("more_than",sum(x),sum(x+1)), stop = TRUE ,sample.size=2)

repro(out)

```

```{r error=TRUE}
set.seed(0)
test(function(x=rinteger()) expect("more_than",sum(x),sum(x+1)), stop = TRUE,sample.size=2)

```

With stop set to true we get a error message and a invetation to load a file that was automatically created. The file containt the cases from the failed tests in a variable called test.cases that can loaded with repro. 


