---
title: "quickcheck Package"
author: "Craig Parman"
date: "2/24/2015"
output: html_document
---

## *quickcheck* Package 


###Introduction

The package quickcheck from [RevolutionAnalytics] http://www.revolutionanalytics.com adds a twist to unit testing. Rather than specifing exact values to be tested, set of random values of a particular type is passed.  


Here is a simple example.  Let's test thet the funtion returns a numeric value. A simple test using testthat might look like:

```{r}
library(testthat)

test_that("rest for floor", expect_identical(is.numeric(floor(3.14)), TRUE))


```

Here we specify the exact value 3.14 to be passed to the function floor.  With quickcheck you don't specify the value, but rather the type of a set of random variables to be passed to the function.  The function, `test`, uses randomly generate input values created by a generator function to test the assertion and collects the result.

```{r}
library(quickcheck)

test(function(x = rdouble())  identical(is.numeric(floor(x)), TRUE))


```



The test is not being run on a single value for x, but a series of values of type double generated by rdouble.  

In the example, the generator `rdouble` generated a list of random value of type double and passes then to `identical(is.numeric(floor(x)), TRUE)`. The these componts together form the assertion. The assertion must return a logical vector of length 1.  Now tha you get the idea lets look at the components closer.

###Building tests


The main function in quickcheck in test. The usage is:

`test(assertion, sample.size = 10, stop = !interactive())'. 

The `assertion` is a function and must return a single logical value for each time the assertion is tested. The returned logical value determines if the test has passed. The value for `sample.size` determines how many time to check the assertion and `stop` determines where a failed test and the associated error will stop R execution.

When the assertion returns TRUE value returned by `test` is `TRUE`. If the assertion returns `FALSE` the output depends on the `stop` parameter. If `stop` is `FALSE` a list with three elements is returned consisting of 1) the assertion 2) a list of in scope variabels (not fully implemented as of Feb. 2015), 3) List of arguments for each run. If the stop is `TRUE` a file is created which contants the list with the above values and is named `test.cases`. This file can be used to replicate errors. The error messsage generated reports the file names.


The most trival test that we could contruct would be:

```{r}

test(function()TRUE)

```

Here we are just returning TRUE, so the test is passed.  In fact we ran the test 10 times, as that is the default for how many time the assertion is checked.  If we wan to so see that we can run.

```{r}

t<-test(function()FALSE, sample.size = 2, stop=FALSE)
 

```

In the output see that the test failed twice and there are 2 cases in the cases portion of the output list.

```{r}

t<-test(function(x=rdouble())FALSE, sample.size = 2, stop=FALSE)

```



The generator, in this case `rdouble` can take on many different forms and the package provide serveral built in and a mechanism to create your own.

In fact you not only get a random set of doubles, you get a randon number of values.  To see this lets run rdouble twice.  We will set the random number seed to 0 for reproducibility.

```{r}
library(quickcheck)

set.seed(0)

rdouble()

rdouble()

```

 
In the first case we get 13 values and in the second we get 9.  We can further control the number generation with the element and size parameters. The element value sets expectation of the values and size sets the average number of values returned as displayed below.


```{r}
library(quickcheck)

set.seed(0)

set1 <- rdouble(element=100,size=10)

set2 <-rdouble(element=10,size=100)

mean(set1)
length(set1)

mean(set2)
length(set2)

```



The power of quickcheck comes from you can pass a



####Usage

###Examples
